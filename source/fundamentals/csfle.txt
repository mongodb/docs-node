==================================
Client-Side Field Level Encryption
==================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. explain relationship between mongodb-client-encryption and CSFLE in node driver

Overview
--------

In this guide, you can learn how to install and use **Client-Side Field
Level Encryption (CSFLE)** in the MongoDB Node.js driver.

CSFLE allows you to encrypt specific data fields within a document with
your MongoDB client application before sending the data to the server.
Starting in MongoDB 4.2 Enterprise, you can perform this client-side 
encryption automatically.

With CSFLE, your client application encrypts fields client-side without 
requiring any server-side configuration or directives. CSFLE is useful 
for situations in which applications must guarantee that unauthorized 
parties, including server administrators, cannot read the encrypted 
data.

This guide is a quick introduction to CSFLE using the Node.js driver. 
For in-depth information on how CSFLE works, see
the :manual:`CSFLE reference </core/security-client-side-encryption/>` 
documentation. For a real-world scenario and implementation, see our 
`CSFLE Guide <https://docs.mongodb.com/drivers/security/client-side-field-level-encryption-guide>`_.

Installation
------------

To get started with CSFLE in your client application, you need

- the MongoDB Node.js driver
- `mongodb-client-encryption <https://www.npmjs.com/package/mongodb-client-encryption>`__
- `uuid-base64 <https://www.npmjs.com/package/uuid-base64#installation>`__
- ``mongocryptd`` if using automatic encryption (Enterprise or Atlas)

``mongodb-client-encryption``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``mongodb-client-encryption`` module is the official client 
encryption module for the MongoDB Node.js driver. It contains bindings 
to communicate with the native library that manages the encryption.

Add it to your project using ``npm``:

.. code-block:: sh
   :copyable: true

   npm install mongodb-client-encryption --save

``uuid-base64``
~~~~~~~~~~~~~~~

The ``uuid-base64`` module converts between Base64 and hexadecimal 
UUIDs.

Add it to your project using ``npm``:

.. code-block:: sh
   :copyable: true

   npm install uuid-base64 --save

``mongocryptd``
~~~~~~~~~~~~~~~

``mongocryptd`` is a binary run as a daemon / process that is used for 
automatic encryption. ``mongodb-crypt`` communicates with 
``mongodb-client-encryption`` to automatically encrypt the information 
specified by a user-provided 
:manual:`JSON Schema </reference/security-client-side-automatic-json-schema/>`.

For more detailed information on ``mongocryptd``, see the
:manual:`mongocryptd reference documentation </reference/security-client-side-encryption-appendix/#mongocryptd>`

Example
-------

To run an example of client-side field level encryption with a local 
key using the Node.js driver, see MongoDB University's GitHub 
`Node CSFLE Example <https://github.com/mongodb-university/csfle-guides/tree/master/nodejs>`__.

.. warning::

   MongoDB recommends using local key management only for testing 
   purposes, and using a remote key management service
   for production.

The examples on this page use a local key, but you can also use integrated support for cloud-based key management
services from AWS, Azure, and GCP. Each example program execution creates a new master key in memory and drops the
``test.coll`` collection.

.. tip::

   In the examples, the in-memory master key is lost when the application finishes running. If you'd like to retain
   and decrypt documents from previous runs, you can save the local master key to a file for reuse and remove the logic
   to drop the collection.

.. warning::

   MongoDB recommends using local key management only for testing purposes, and using a remote key management service
   for production.

.. _auto-encryption-decryption-java:

Automatic Encryption and Decryption
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example shows how to use ``mongodb-client-encryption`` to 
configure a CSFLE-enabled client with a data key and JSON schema map.

The data in sensetive fields is automatically encrypted 
before insertion, and decrypted when calling ``findOne()``
on the client side. Querying this collection from a client that isn't 
configured for CSFLE will return the document in encrypted form.

.. note::

   Auto encryption requires MongoDB **Enterprise** or **Atlas**.

.. code-block:: node

   // Import "mongodb" and "mongodb-client-encryption"
   const mongodb = require("mongodb")
   const { ClientEncryption } = require("mongodb-client-encryption")
   
   // Set your database URI
   const uri = "mongodb+srv://<user>>:<password>@cluster0.gvzx6.mongodb.net/myFirstDatabase?retryWrites=true&w=majority";
   
   // Create a regular client without encryption/ decryption capabilities
   async function getRegularClient() {
     const client = new mongodb.MongoClient(uri, {
       useNewUrlParser: true,
       useUnifiedTopology: true,
     })
     return await client.connect()
   }
   
   const regularClient = getRegularClient();
   
   // Create a data key
   async function getDataKey(client) {
     const encryption = new ClientEncryption(client, {
       keyVaultNamespace: 'encryption.__keyVault',
       kmsProviders: null
     })
   
     dataKey = await encryption.createDataKey("local")
     return dataKey.toString("base64")
   }
   
   const dataKey = getDataKey(regularClient);
   
   // Create a JSON schema map with the data key
   function createJsonSchemaMap(dataKey) {
     return {
       "medicalRecords.patients": {
         bsonType: "object",
         // specify the encryptMetadata key at the root level of the JSON Schema.
         // As a result, all encrypted fields defined in the properties field of the
         // schema will inherit this encryption key unless specifically overwritten.
         encryptMetadata: {
           keyId: [new Binary(Buffer.from(dataKey, "base64"), 4)]
         },
         properties: {
           insurance: {
             bsonType: "object",
             properties: {
               policyNumber: {
                 encrypt: {
                   bsonType: "int",
                   algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
                 }
               }
             }
           },
           medicalRecords: {
             encrypt: {
               bsonType: "array",
               algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
             }
           },
           bloodType: {
             encrypt: {
               bsonType: "string",
               algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
             }
           },
           ssn: {
             encrypt: {
               bsonType: "int",
               algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
             }
           }
         }
       }
     }
   }
   
   const schemaMap = createJsonSchemaMap(dataKey);
   
   // Use the data key and schema to create a CSFLE-enabled client
   async function getCsfleEnabledClient(schemaMap) {
     const client = new mongodb.MongoClient(uri, {
       useNewUrlParser: true,
       useUnifiedTopology: true,
       monitorCommands: true,
       autoEncryption: {
         // The key vault collection contains the data key that the client uses to encrypt and decrypt fields.
         keyVaultNamespace: 'encryption.__keyVault',
         // The client expects a key management system to store and provide the application's master encryption key.
         // For now, we will use a local master key, so they use the local KMS provider.
         kmsProviders: null,
         // The JSON Schema that we have defined doesn't explicitly specify the collection to which it applies.
         // To assign the schema, they map it to the medicalRecords.patients collection namespace
         schemaMap
       }
     })
     return await client.connect()
   }
   
   const csfleClient = getCsfleEnabledClient(schemaMap);
   
   // Create sample data
   let exampleDocument = {
     name: "Jon Doe",
     ssn: 241014209,
     bloodType: "AB+",
     medicalRecords: [
       {
         weight: 180,
         bloodPressure: "120/80"
       }
     ],
     insurance: {
       provider: "MaestCare",
       policyNumber: 123142
     }
   }
   
   const regularClientPatientsColl = regularClient
     .db("medicalRecords")
     .collection("patients")
   const csfleClientPatientsColl = csfleClient
     .db("medicalRecords")
     .collection("patients")
   
   // Insert sample data with an encrypted field using the CSFLE client
   async function upsertExampleData() {
     await csfleClientPatientsColl.updateOne(
       { ssn: exampleDocument["ssn"] },
       { $set: exampleDocument },
       { upsert: true }
     )
   }
   
   upsertExampleData();
   
   async function compareResults() {
     // Decrypt data with a CSFLE client using findOne()
     const csfleFindResult = await csfleClientPatientsColl.findOne({
       ssn: exampleDocument["ssn"]
     })
     console.log(
       "Document retreived with csfle enabled client:\n",
       csfleFindResult
     )
   
     // View encrypted data from a regular client using findOne()
     const regularFindResult = await regularClientPatientsColl.findOne({
       name: "Jon Doe"
     })
     console.log("Document retreived with regular client:\n", regularFindResult)
     
     await regularClient.close()
     await csfleClient.close()
   }
   
   compareResults();

   