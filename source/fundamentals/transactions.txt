.. _nodejs-transactions:

============
Transactions
============

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Overview
--------

In this guide, you can learn how to use the
{+driver-short+} to perform **transactions**. Transactions allow you
to run a series of operations that do not change any data until the
entire transaction is committed. If any operation in the transaction fails, the 
driver aborts the transaction and discards all data changes before they
ever become visible. This feature is called **atomicity**.

Since all write operations on a single document in MongoDB are atomic, you
might want to use transactions to make an atomic change that
modifies multiple documents. This situation would require a multi-document transaction.
Multi-document transactions are **ACID compliant** because MongoDB
guarantees that the data involved in your transaction operations remains
consistent, even if the driver encounters unexpected errors.

To learn more about ACID compliance and transactions, see our :website:`article on
ACID transactions </basics/acid-transactions>`.

.. note::

   To execute a multi-document transactions, you must be connected to a
   deployment running MongoDB Server version 4.0 or later.

   For a detailed list of limitations, see the :manual:`Transactions and
   Operations </core/transactions/#transactions-and-operations>` section in
   the Server manual.

In MongoDB, multi-document transactions run within a **client session**.
A client session is a grouping of related read or write operations that
you want to execute sequentially. We recommend you reuse
your client for multiple sessions and transactions instead of
instantiating a new client each time.

When combined with ``majority`` read and
write concerns, the driver guarantees causal consistency between the
operations. To learn more, see :manual:`Client Sessions and Causal Consistency Guarantees
</core/read-isolation-consistency-recency/#client-sessions-and-causal-consistency-guarantees>` in the
Server manual.

Learn more about how to use the driver to perform multi-document
transactions in the following sections of this guide:

- :ref:`Transaction API <nodejs-transaction-apis>`
- :ref:`Transaction Settings <nodejs-transaction-settings>`
- :ref:`Core API Examples <nodejs-transaction-examples>`

.. _nodejs-transaction-apis:

Transaction APIs
----------------

The driver provides multiple APIs for performing transactions, including
the **Core API** and Convenient Transaction API. To begin using the Core
API, declare the start and commit points of the transaction.

To see an example that uses the Convenient Transaction API, see the
:ref:`Perform a Convenient Transaction <node-usage-convenient-txn>` usage example.

Core API
~~~~~~~~

The Core API provides methods to start, cancel, or commit transactions.
When you commit a transaction, you send a request to the server to make the
changes from your operations atomically. When using this API, you must handle
certain transaction errors returned by the server manually.

To learn more about these error types, see
:manual:`TransientTransactionError
</core/transactions-in-applications/#std-label-transient-transaction-error>`
and :manual:`UnknownTransactionCommitResult
</core/transactions-in-applications/#-unknowntransactioncommitresult->`
in the Server manual.

Once you create a ``Session`` instance, to start, cancel, or commit your
transaction, call the necessary method on the session:

- ``startTransaction()``
- ``commitTransaction()``
- ``abortTransaction()``

To see a sample implementation that uses this API, see the :ref:`Core
API example <nodejs-transaction-core-api-example>`.

.. _nodejs-transaction-settings:

Transaction Options
-------------------

You can specify the following options to
specify the behavior for a transaction when creating it:

.. list-table::
   :widths: 25 75
   :header-rows: 1

   * - Setting
     - Description

   * - ``readConcern``
     - | Controls the consistency of the data that
         read operations retrieve from a replica set.
       | To learn more, see :manual:`Read Concern
         </reference/read-concern/>` in the Server manual.

   * - ``writeConcern``
     - | Specifies the level of acknowledgment requested from MongoDB
         for write operations to a replica set.
       | To learn more, see :manual:`Write Concern
         </reference/write-concern/>` in the Server manual.

   * - ``readPreference``
     - | Specifies how to route read operations to members of a replica set.
       | To learn more, see :manual:`Read Preference
         </core/read-preference/#read-preference>` in the Server manual.

   * - ``maxCommitTimeMS``
     - Specifies the maximum amount of time that a commit action on a
       transaction can run, in milliseconds.

If you do not provide values, the driver inherits settings from your
``MongoClient`` instance.

The following code shows how to define and pass transaction options to
the ``startTransaction()`` method:

.. code-block:: javascript

   const transactionOptions = {
     readPreference: 'primary',
     readConcern: { level: 'local' },
     writeConcern: { w: 'majority' },
     maxCommitTimeMS: 1000
   };
   session.startTransaction(transactionOptions);

.. _nodejs-transaction-examples:

Example
-------

Consider a situation where a customer purchases items from your online
store. To record the purchase, your application must update
information related to inventory and the customer's orders. Your
application also needs to register the order details.

The following table describes a way that you might organize the data
updates:

.. list-table::
   :widths: 25 25 50
   :header-rows: 1

   * - Collection
     - Operation
     - Description of the Change

   * - ``orders``
     - insert
     - Record the purchase information

   * - ``customers``
     - update or upsert
     - Append the order ``_id`` to the document for a customer

   * - ``inventory``
     - update
     - Reduce the quantities to reflect the number of items ordered

A purchase can fail for the following reasons:

- There is an insufficient quantity of the item in the inventory
- The order couldn't be completed
- The payment system is offline

If the payment fails, you can perform a transaction that includes all of
the data changes to ensure you avoid making any partial updates that
might cause data consistency issues for future operations.

Sample Data
~~~~~~~~~~~

The code examples use the following sample data in the ``testdb``
database:

- A document in the ``customers`` collection that describes a customer and
  their orders.
- Documents in the ``inventory`` collection that include quantities and
  descriptions of all items.

The following document is in the ``customers`` collection:

.. code-block:: json

   { _id: 98765, orders: [] }

The following documents are in the ``inventory`` collection:

.. code-block:: json

   { item: "sunblock", sku: 5432, qty: 85 },
   { item: "beach towel", sku: 7865, qty: 41 }

The code examples also perform operations on the ``orders`` collection, but
this collection does not contain any data before the transaction is
performed.

The code examples use the ``cart`` and ``payment`` variables to represent
a sample list of items purchased and the order payment details. The
following code describes the contents of the ``cart`` and ``payment`` variables:

.. code-block:: javascript

   const cart = [
     { item: 'sunblock', sku: 5432, qty: 1, price: 5.19 },
     { item: 'beach towel', sku: 7865, qty: 2, price: 15.99 }
   ];
   const payment = { customer: 98765, total: 37.17 };

.. important::
   
   If you are connected to a deployment running MongoDB Server version
   4.4 or later, you can create collections within transactions.
   Otherwise, you must create the collections outside of the
   transaction. To learn more about creating collections inside a
   transaction, see :manual:`Create Collections and Indexes in a
   Transaction
   </core/transactions/#std-label-transactions-create-collections-indexes>`
   in the Server manual.

.. _nodejs-transaction-core-api-example:

Core API Implementation
~~~~~~~~~~~~~~~~~~~~~~~

The code example in this section demonstrates how to use the Core API to
perform the multi-document transaction in a session. This example
shows how to perform the following actions:

1. Start a session
#. Start a transaction with transaction options
#. Perform data operations in the session
#. Commit the transaction, or abort it if the driver encounters an error
#. End the session

.. literalinclude:: /code-snippets/transactions/txn-core.js
   :language: javascript
   :linenos:
   :emphasize-lines: 2-6,8,10,19,32,41,49,51,55-59,63,65
   :start-after: start placeOrder
   :end-before: end placeOrder

You must pass the session object to each CRUD operation that
you want to run in that session.

.. important:: Use a Session with the Client That Started It
   
   Starting in version 6.0 of the {+driver-short+}, the driver 
   throws an error if you provide a session from one ``MongoClient``
   instance to a different client instance.

   For example, the following code generates an
   ``MongoInvalidArgumentError`` error because it creates
   a ``ClientSession`` instance from the ``client1`` client, but provides
   this session to the ``client2`` client for a write operation:

   .. code-block:: js
      :emphasize-lines: 2
      
      const session = client1.startSession();
      client2.db('myDB').collection('myColl').insertOne({ name: 'Jane Eyre' }, { session });

The code and comments in the ``catch`` block demonstrate how you can identify
the server transaction errors and where you can place your logic to handle
them. Make sure to include the ``MongoError`` type from the driver in your
code as shown in the following sample import statement:

.. code-block:: javascript

   const { MongoError, MongoClient } = require('mongodb');

See the :ref:`Payment Transaction Result <nodejs-transaction-example-payment-result>`
section to see what your collections should contain after you
successfully perform the transaction.

.. tip::
   
   To view an implementation of a simplified example that uses the
   Convenient Transaction API, see the :ref:`Perform a Convenient
   Transaction <node-usage-convenient-txn>` usage example.

.. _nodejs-transaction-example-payment-result:

Payment Transaction Result
~~~~~~~~~~~~~~~~~~~~~~~~~~

If your application completed the payment transaction, the collections
in the database should contain updated data. If an error interrupted the
transaction, none of the changes should be visible in your database.

The ``customers`` collection should contain the customer document with an
order ``_id`` appended to the orders field:

.. code-block:: json
   :copyable: false

   {
     "_id": 98765,
     "orders": [
       "61dc..."
     ]
   }

The ``inventory`` collection should contain updated quantities for the
items ``"sunblock"`` and ``"beach towel"``:

.. code-block:: json
   :copyable: false

   [
     {
       "_id": ...,
       "item": "sunblock",
       "sku": 5432,
       "qty": 84
     },
     {
       "_id": ...,
       "item": "beach towel",
       "sku": 7865,
       "qty": 39
     }
   ]

The ``orders`` collection should contain the order and payment
information:

.. code-block:: json
   :copyable: false

   [
     {
       "_id": "...",
       "customer": 98765,
       "items": [
         {
           "item": "sunblock",
           "sku": 5432,
           "qty": 1,
           "price": 5.19
         },
         {
           "item": "beach towel",
           "sku": 7865,
           "qty": 2,
           "price": 15.99
         }
       ],
       "total": 37.17
     }
   ]

