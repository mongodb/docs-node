==========
TypeScript
==========

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecols

Overview
--------

In this guide, you can learn about the **TypeScript** features and limitations
of the MongoDB Node.js driver. TypeScript is a strongly typed programming
language that compiles to JavaScript.

All TypeScript features of the driver are optional. All valid JavaScript
code written with the driver is also valid TypeScript code.

For more information, see the
`TypeScript website <https://www.typescriptlang.org/>`__.

Features
--------

If you use TypeScript, you can specify a type for some classes in the driver.
All classes that accept a type parameter in the driver have the default type
``Document``. The ``Document`` interface has the following definition:

.. code-block:: typescript

   interface Document {
     [key: string]: any;
   }

All object types extend the ``Document`` interface.

For more information on object types, see the
`TypeScript handbook <https://www.typescriptlang.org/docs/handbook/2/objects.html>`__.

Type Parameters that Extend Document
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following classes accept all types that both extend
the ``Document`` interface and are not mutually recursive:

.. _node-mongodb-type-parameters-extend-document:

- `Collection <{+api+}/classes/Collection.html>`__
- `ChangeStream <{+api+}/classes/ChangeStream.html>`__

You can pass a type parameter that extends the ``Document`` interface like this:

.. _mongodb-node-typescript-pet-interface:

.. literalinclude:: /code-snippets/typescript/extend-document.ts
   :language: typescript
   :linenos:

.. important:: Keys Not in Type Parameter Receive ``any`` Type

   Keys not listed in your specified type parameter receive the ``any`` type.
   The following code snippet demonstrates this behavior:

   .. literalinclude:: /code-snippets/typescript/dot-notation.ts
      :language: typescript
      :linenos:
      :start-after: start-no-key
      :end-before: end-no-key

To view an example of a mutually recursive type, which is not supported by the
:ref:`preceding classes <node-mongodb-type-parameters-extend-document>`,
see the :ref:`<node-driver-limitations-mutual-recursion>` section.

Type Parameters of Any Type
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following classes accept all type parameters that are not mutually recursive:

.. _node-mongodb-type-parameters-any-type:

- `FindCursor <{+api+}/classes/FindCursor.html>`__
- `AggregationCursor <{+api+}/classes/AggregationCursor.html>`__

You can find a code snippet that shows how to specify a type for the ``FindCursor``
class in the
:ref:`Find Multiple Documents Usage Example <node-driver-find-usage-example-code-snippet>`.

To view an example of a mutually recursive type, which is not supported by the
:ref:`preceding classes <node-mongodb-type-parameters-any-type>`,
see the :ref:`<node-driver-limitations-mutual-recursion>` section.


Type Safety and Dot Notation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you specify a query or update with **dot notation**, the {+driver-short+}
provides type safety if your query or update does not
:ref:`reference a nested instance of a recursive type <node-driver-recursive-types-dot-notation>`.
Dot notation is a syntax you can use to navigate nested JSON objects.

The following code snippet defines the ``ClassificationPet`` interface,
which includes a ``classification`` field that enables you to specify the
genus and color of dogs and cats:

.. code-block:: typescript

   interface ClassificationPet {
     name: string;
     age: number;
     classification: { genus: "Canis" | "Felis"; color: string };
   }

The following code snippet correctly raises a type error when specifying
the genus of an unsupported animal in a query:

.. code-block:: typescript

   database
     .collection<ClassificationPet>("<your collection>")
     .find({ "classification.genus": "Sylvilagus" });

The type error raised by the preceding code snippet is as follows:

.. code-block:: none

   No overload matches this call.
   ...
   Type '"Sylvilagus"' is not assignable to type 'Condition<"Canis" | "Felis">'.

To learn more about dot notation, see
:manual:`Dot Notation </core/document/#dot-notation>`
in the MongoDB manual.

To learn more about the limitations of dot notation in the
{+driver-short+}, see the
:ref:`<node-driver-recursive-types-dot-notation>`
section.

.. _node-driver-limitations:

Insert Operations and the _id Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

How you specify the ``_id`` field in type parameters passed to your
``Collection`` instance affects the behavior
of insert operations. The following table describes how different
``_id`` field specifications affect insert operations:

.. list-table::
   :header-rows: 1
   :widths: 20 20 20 40

   * - ``_id`` field type
     - Example Type
     - Required on insert
     - Behavior on insert

   * - | Unspecified
     - | Not applicable
     - | No
     - | The driver creates an 
         :manual:`ObjectId </reference/method/ObjectId/>`
         value for each inserted document.

   * - | Specified
     - | ``{ _id: number };`` 
     - | Yes
     - | If you do not specify a value for the ``_id`` field in an insert operation,
         the driver raises an error.

   * - | Specified as optional
     - | ``{ _id?: number };``
     - | No
     - | If you do not specify the ``_id`` field in an insert operation,
         the driver adds an ``_id`` field value generated by a
         **primary key factory**.
       | A primary key factory is a class that defines a system for creating
         unique identifiers for documents and implements the ``PkFactory``
         interface.
       | The default primary key factory generates ``_id`` values of type
         ``ObjectId``.

If you must specify the ``_id`` field as required in the type you define to represent
documents in your collection but you do not want to specify values for the
``_id`` field in insert operations, use the ``OptionalId`` helper type when you
create your collection. The ``OptionalId`` type accepts a type parameter as an
argument and returns that type with an optional ``_id`` field.

The following code snippet defines the ``IdPet`` interface, which
includes a type for the ``_id`` field:

.. code-block:: typescript

   interface IdPet {
     _id: ObjectId;
     name: string;
     age: number;
   }

The following code uses the preceding interface along with the
``OptionalId`` type to insert a document without specifying a value for the
``_id`` field:

.. code-block:: typescript

   const database = client.db("<your database>");
   const collection = db.collection<OptionalId<IdPet>>("<your collection>");
   
   collection.insertOne({
     name: "Spot",
     age: 2
   });

.. important:: Data Consistency and Optional _id Types

   If you do not specify a primary key factory method that generates
   ``_id`` values of your desired type, you may experience data inconsistency.
   This occurs because the driver's default primary factory method generates
   ``_id`` values of type ``ObjectId`` regardless of the type you specify for the 
   ``_id`` field in your type parameter.

   To show this behavior, assume you apply the following interface to
   your ``Collection`` instance:

   .. code-block:: typescript

      interface I {
        _id?: number;
        name: string;
      } 

   The following sequence of insert operations inserts one document
   with an ``_id`` of type ``number`` and one document with an 
   ``_id`` of type ``ObjectId`` into your collection:

   .. code-block:: typescript

      collection.insertOne({ _id: 1, name: "Scar" });
      collection.insertOne({ name: "Ursula" });

   To ensure that your data is consistent, apply a primary key factory to
   your ``MongoClient`` instance like this:

   .. code-block:: typescript

      const client = new MongoClient(uri, {
        pkFactory: { createPk: () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER) },
      });

To learn more about the ``_id`` field, see
:manual:`The _id Field </core/document/#the-_id-field>` in the MongoDB
manual.

To learn more about the types, interfaces, and classes discussed in this section, see the
following resources:

- `OptionalId <{+api+}/modules.html#OptionalId>`__ API documentation
- `PkFactory <{+api+}/interfaces/PkFactory.html>`__ API documentation
- :github:`ObjectId <mongodb/js-bson/blob/master/src/objectid.ts>` source code

Find Methods and the _id Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``find`` and ``findOne`` methods of the ``Collection`` class include
the ``_id`` field in their return type.

If the type parameter you passed to your ``Collection`` instance includes the
``_id`` field, the type of the ``_id`` field in the values returned from the 
find methods is the same as the type of the ``_id``
field in your type parameter.

If the type parameter you passed to your ``Collection`` instance does not include the ``_id``
field, the driver gives the ``_id`` field in the values returned from the find methods
the type ``ObjectId``.

The following code uses the :ref:`Pet <mongodb-node-typescript-pet-interface>` interface to return
a document with an ``_id`` of type ``ObjectId``:

.. code-block:: typescript

   const database = client.db("<your database>");
   const collection = db.collection<Pet>("<your collection>");
   
   const document = await collection.findOne({
     name: "Spot",
   });
   const id : ObjectId = document._id;

The following code uses the ``IdNumberPet`` interface to return a
document with an ``_id`` field of type ``number``:

.. code-block:: typescript

   interface IdNumberPet {
     _id: number;
     name: string;
     age: number;
   }

   const database = client.db("<your database>");
   const collection = db.collection<IdNumberPet>("<your collection>");

   const document = await collection.findOne({
     name: "Spot",
   });
   const id : number = document._id;

.. important:: Projection

   If you specify a :ref:`projection <mongodb-node-projection>` in a find
   method, you should pass a type parameter to your find method that reflects
   the structure of your projected documents.
   Without a type parameter, TypeScript cannot check at compile time that you
   are using your projected documents safely.

   To show this behavior, the following code snippet passes type checking but
   raises an error at runtime:

   .. code-block:: typescript

      const doc = await collection.findOne(
        {},
        { projection: { _id: 0, name: 1 } }
      );
      console.log(doc._id.generationTime);

   To catch this error at compile time, pass a type parameter that does not include
   the ``_id`` field to your find method:

   .. code-block:: typescript

      interface ProjectedDocument {
         name: string
      }

      const doc = await collection.findOne<ProjectedDocument>(
        {},
        { projection: { _id: 0, name: 1 } }
      );
      // Compile time error: Property '_id' does not exist on type 'ProjectedDocument'.
      console.log(doc._id.generationTime);
   
   To view a runnable TypeScript example that includes a find method applying a
   projection, see the
   :ref:`Find a Document <node-driver-findone-usage-example-code-snippet>` page.


To learn more about the classes and methods discussed in this section, see the following
API documentation:

- `Collection <{+api+}/classes/Collection.html>`__
- `find <{+api+}/classes/Collection.html#find>`__
- `findOne <{+api+}/classes/Collection.html#findOne>`__

Known Limitations
-----------------

.. include:: includes/limitations/limits.rst
