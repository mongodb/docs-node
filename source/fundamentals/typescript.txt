==========
TypeScript
==========

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecols

Overview
--------

In this guide, you can learn about the **TypeScript** features and limitations
of the MongoDB Node.js driver. TypeScript is a strongly typed programming
language that compiles to JavaScript.

All TypeScript features of the driver are optional. All valid JavaScript
code written with the driver is also valid TypeScript code.

For more information, see the
`TypeScript website <https://www.typescriptlang.org/>`__.

Features
--------

If you use TypeScript, you can specify a type for some classes in the driver.
All classes that accept a type parameter in the driver have the default type
``Document``. The ``Document`` interface has the following definition:

.. code-block:: typescript

   interface Document {
     [key: string]: any;
   }

Any object type can extend the ``Document`` interface.

For more information on object types, see the
`TypeScript handbook <https://www.typescriptlang.org/docs/handbook/2/objects.html>`__.

Type Parameters that Extend Document
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following classes accept all types that both extend
the ``Document`` interface and are not mutually recursive:

- `Collection <{+api+}/classes/Collection.html>`__
- `ChangeStream <{+api+}/classes/ChangeStream.html>`__

You can pass a type parameter that extends the ``Document`` interface like this:

.. _mongodb-node-typescript-pet-interface:

.. literalinclude:: /code-snippets/typescript/extend-document.ts
   :language: typescript
   :linenos:

.. important:: Keys Not in Type Parameter Receive ``any`` Type

   Keys not listed in your specified type parameter receive the ``any`` type.
   The following code snippet demonstrates this behavior:

   .. literalinclude:: /code-snippets/typescript/dot-notation.ts
      :language: typescript
      :linenos:
      :start-after: start-no-key
      :end-before: end-no-key

To view an example of a mutually recursive type, which is not supported by the
preceding classes, see the :ref:`<node-driver-limitations-mutual-recursion>` section.

Type Parameters of Any Type
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following classes accept all type parameters that are not mutually recursive:

- `FindCursor <{+api+}/classes/FindCursor.html>`__
- `AggregationCursor <{+api+}/classes/AggregationCursor.html>`__

You can find a code snippet that shows how to specify a type for the ``FindCursor``
class in the
:ref:`Find Multiple Documents Usage Example <node-driver-find-usage-example-code-snippet>`.

To view an example of a mutually recursive type, which is not supported by the
preceding classes, see the :ref:`<node-driver-limitations-mutual-recursion>` section.

.. _node-driver-limitations:

Limitations For Driver Version {+version+}
----------------------------------

The following subsections describe the TypeScript specific limitations of
version {+version+} of the {+driver-long+}. 

Many limitations of the {+driver-short+} relate to **recursive types**.
A recursive type is a type that references itself. You can update
the :ref:`Pet <mongodb-node-typescript-pet-interface>` interface
to be recursive by allowing a pet to have its own pet. The following is the
recursive ``Pet`` interface:

.. _node-driver-limitations-recursive-pet:

.. code-block:: typescript
   :emphasize-lines: 2

   interface RecursivePet {
      pet?: RecursivePet;
      name: string;
      age: number;
   }

Recursive Types and Dot Notation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The {+driver-short+} cannot provide type safety within nested instances of
recursive types referenced through **dot notation**. Dot notation is a property
access syntax for navigating BSON objects.

For example, the following code snippet references a nested instance of the
:ref:`RecursivePet <node-driver-limitations-recursive-pet>` interface
with an incorrect type using dot notation, but the TypeScript compiler
does not raise an error:

.. code-block:: typescript
   :emphasize-lines: 3

   database
      .collection<RecursivePet>("your-collection")
      .findOne({ "pet.age": "Spot" });

The following code snippet references a top-level instance of the
``RecursivePet`` interface with an incorrect type and raises a type error:

.. tabs::

   .. tab:: Code Snippet
      :tabid: code-snippet

      .. code-block:: typescript
         :emphasize-lines: 3

         database
           .collection<RecursivePet>("your-collection")
           .findOne({ pet: "Spot" });

   .. tab:: Error
      :tabid: error

      .. code-block:: text
                  
         index.ts(19,59): error TS2769: No overload matches this call.
         The last overload gave the following error.
         Type 'string' is not assignable to type 'Condition<Pet>'.

If you must have type safety within nested instances of recursive types,
you must write your query or update without dot notation.

To learn more about dot notation, see 
:manual:`Dot Notation </core/document/#dot-notation>`
in the MongoDB manual.

.. _node-driver-limitations-mutual-recursion:

Mutual Recursion
~~~~~~~~~~~~~~~~

You cannot specify a mutually recursive type as a type parameter in version
{+version+} of the driver.

If you specify a mutually recursive type, the TypeScript compiler raises the
following error:

.. code-block:: text

   error TS2615: Type of property 'r' circularly references itself in mapped type '{ [Key in keyof MutuallyRecursive]: MutuallyRecursive[Key] extends MutuallyRecursive ? [Key] : MutuallyRecursive extends MutuallyRecursive[Key] ? [...] : MutuallyRecursive[Key] extends readonly (infer ArrayType)[] ? MutuallyRecursive extends ArrayType ? [...] : ArrayType extends MutuallyRecursive ? [...] : [...] : [...'.

A mutually recursive type exists when two types define themselves relative
to each other. You can update the
:ref:`Pet <mongodb-node-typescript-pet-interface>` interface
to be mutually recursive by allowing a pet to have a handler, and defining a
handler to have a pet. The following is the mutually
recursive ``Pet`` interface:

.. code-block:: typescript
   :emphasize-lines: 2, 8

   interface MutuallyRecursivePet {
      handler?: Handler;
      name: string;
      age: number;
   }

   interface Handler {
      pet: MutuallyRecursivePet;
      name: string;
   }

If you must apply a mutually recursive type to your classes, use version 4.2 of
the {+driver-long+}.
