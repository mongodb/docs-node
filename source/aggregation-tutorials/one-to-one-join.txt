.. _node-aggregation-one-to-one:

===============
One-to-One Join
===============

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. facet::
   :name: genre
   :values: tutorial

.. meta::
   :keywords: code example, node.js, lookup, aggregation

Introduction
------------

In this tutorial, you can learn how to use the {+driver-short+} to
perform a one-to-one join. A one-to-one join occurs when a document
in one collection has a field value that matches a single document in
another collection with the same field value. The aggregation matches
these documents on the field value and combines information from both
into one document.

.. tip::

   A one-to-one join does not require the documents to have a
   one-to-one relationship. To learn more about this data relationship,
   see the Wikipedia entry about :wikipedia:`One-to-one (data model)
   <w/index.php?title=One-to-one_(data_model)&oldid=1096960092>`.

Aggregation Task Summary
~~~~~~~~~~~~~~~~~~~~~~~~

This aggregation tutorial demonstrates how to join data from two
collections related to product information and customer orders.
The aggregated result is a list of all orders placed in 2020 that
includes the product details associated with each order.

This example uses two collections:

- ``orders``, which contains documents describing individual orders
  for products in a shop
- ``products``, which contains documents describing the products that
  a shop sells

An order can only contain one product, so the aggregation uses a
one-to-one join to match an order document to the document for the ordered
product. The collections are joined by a field called ``product_id``
that exists in documents in both collections.

Before You Get Started
----------------------

Before you start following this tutorial, follow the
instructions in the :ref:`node-agg-tutorial-template-app` section of the
Aggregation Tutorials page to set up the template app.

Once you set up the app, access the ``products`` and ``orders``
collections by updating the collection name placeholders, as shown in
the following code:

.. literalinclude:: /includes/aggregation/one-to-one-join.js
   :language: javascript
   :copyable: true
   :start-after: start-colls
   :end-before: end-colls
   :dedent:

Insert sample data into the ``orders`` collection by
pasting the following sample documents into the ``sampleData1`` array:

.. literalinclude:: /includes/aggregation/one-to-one-join.js
   :language: javascript
   :copyable: true
   :start-after: start-orders
   :end-before: end-orders
   :dedent:

Insert sample data into the ``products`` collection by
pasting the following sample documents into the ``sampleData2`` array:

.. literalinclude:: /includes/aggregation/one-to-one-join.js
   :language: javascript
   :copyable: true
   :start-after: start-products
   :end-before: end-products
   :dedent:

Tutorial
--------

.. procedure::
   :style: connected

   .. step:: Build The Aggregation Pipeline

      .. procedure::
         :style: connected

         .. step::

            Add a :manual:`$match
            </reference/operator/aggregation/match>` stage that matches
            orders placed in 2020:

            .. literalinclude:: /includes/aggregation/one-to-one-join.js
               :language: javascript
               :copyable: true
               :start-after: start-match
               :end-before: end-match
               :dedent:

         .. step::

            Next, add a :manual:`$lookup
            </reference/operator/aggregation/lookup>` stage. The
            ``$lookup`` stage joins the ``product_id`` field in the ``orders``
            collection, to the ``id`` field in the ``products`` collection:

            .. literalinclude:: /includes/aggregation/one-to-one-join.js
               :language: javascript
               :copyable: true
               :start-after: start-lookup
               :end-before: end-lookup
               :dedent:

         .. step::

            Next, add two :manual:`$set </reference/operator/aggregation/set>`
            stages to the pipeline.
            
            The first ``$set`` stage, sets the ``product_mapping`` field
            to the first element in the ``product_mapping`` object
            created in the previous ``$lookup`` stage. 

            The second ``$set`` stage creates a new ``product_name`` and
            ``product_category`` field from the values in the
            ``product_mapping`` object:

            .. literalinclude:: /includes/aggregation/one-to-one-join.js
               :language: javascript
               :copyable: true
               :start-after: start-set
               :end-before: end-set
               :dedent:

            .. tip::

               Because this is a one-to-one join, the ``$lookup`` stage
               adds only one array element to the input document. The pipeline
               uses the :manual:`$first </reference/operator/aggregation/first>`
               operator to retrieve the data from this element.

         .. step::

            Finally, add an :manual:`$unset
            </reference/operator/aggregation/unset>` stage. The
            ``$unset`` stage removes unnecessary fields from the document:
            
            .. literalinclude:: /includes/aggregation/one-to-one-join.js
               :language: javascript
               :copyable: true
               :start-after: start-unset
               :end-before: end-unset
               :dedent:

   .. step:: Run the Aggregation Pipeline

      Run the following command in your shell to perform the aggregation
      on the ``products`` collection:

      .. code-block:: bash
      
         node agg_tutorial.js

      The aggregated result contains three documents. The documents
      represent customer orders that occurred in 2020, with the
      ``product_name`` and ``product_category`` of the ordered product:

      .. code-block:: javascript
         :copyable: false
         
         {
           customer_id: 'elise_smith@myemail.com',
           orderdate: 2020-05-30T08:35:52.000Z,
           value: 431.43,
           product_name: 'Asus Laptop',
           product_category: 'ELECTRONICS'
         }
         {
           customer_id: 'oranieri@warmmail.com',
           orderdate: 2020-01-01T08:25:37.000Z,
           value: 63.13,
           product_name: 'Morphy Richardds Food Mixer',
           product_category: 'KITCHENWARE'
         }
         {
           customer_id: 'jjones@tepidmail.com',
           orderdate: 2020-12-26T08:55:46.000Z,
           value: 429.65,
           product_name: 'Asus Laptop',
           product_category: 'ELECTRONICS'
         }

      The result consists of documents that contain fields from
      documents in the ``orders`` collection and the ``products``
      collection, joined by matching the ``product_id`` field present in
      each original document.

To see the complete code for this tutorial, see the `Complete One-to-one Join Tutorial
<https://github.com/mongodb/docs-node/tree/master/source/includes/aggregation/one-to-one-join.js>`__.
